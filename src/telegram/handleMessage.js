const bot = require("./botConfig");
const geminiService = require("../api/gemini/geminiService");
const openService = require("../api/openai/openaiService");
const prompts = require("../models/instructions");
const parseJsonString = require("../helpers/parseJsonString");
const extractJsonSubstring = require("../helpers/extractJsonSubstring");
const isDev = process.env.NODE_ENV === "development";

module.exports = async function () {
  const history = {};
  const dialogs = [];
  const state = {};
  const emptyProps = {};

  const handleSendMessage = (id, message, options) => {
    bot.sendMessage(id, `${isDev ? "DEV" : ""}\n${message}`, options);
  };

  const AIResponse = async (context, prompt, instructions, temperature = 0) => {
    return await geminiService.generateChatText({
      context,
      prompt,
      history: instructions,
      temperature,
    });
  };

  const mergeContext = (id, message, role = "–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç") => {
    const date = new Date();
    const item = `
    —Ä–æ–ª—å: ${role};
    —Å–æ–∑–¥–∞–Ω–æ: ${date};
    –¥–∏–∞–ª–æ–≥: ${message}.`;
    context[id] = context[id] ? [context[id], item] : [item];
  };

  const mergeState = (id, data) => {
    const localState = (state[id] = state[id]
      ? { ...state[id], ...data }
      : data);
    return localState;
  };

  const getFieldsWithValues = (jsonObject) => {
    const withValues = {};

    const processObject = (inputObj, outputWithValues) => {
      Object.keys(inputObj).forEach((key) => {
        const value = inputObj[key];

        if (value !== null && value !== undefined) {
          outputWithValues[key] = value;
        }

        if (typeof value === "object" && value !== null) {
          outputWithValues[key] = {};
          processObject(value, outputWithValues[key]);
        }
      });
    };

    processObject(jsonObject, withValues);

    return withValues;
  };
  const findEmptyFields = (formData) => {
    const emptyFields = {};

    const processObject = (data, path = "") => {
      Object.keys(data).forEach((key) => {
        const value = data[key];
        const currentPath = path ? `${path}.${key}` : key;

        if (isEmpty(value)) {
          emptyFields[currentPath] = value;
        } else if (typeof value === "object" && !Array.isArray(value)) {
          processObject(value, currentPath);
        }
      });
    };

    const isEmpty = (value) => {
      return (
        value === null ||
        value === undefined ||
        value === "" ||
        (Array.isArray(value) && value.length === 0) ||
        (typeof value === "object" && Object.keys(value).length === 0)
      );
    };

    processObject(formData);

    return emptyFields;
  };
  const mergeObjects = (obj1, obj2) => {
    const result = { ...obj1 };

    for (const key in obj2) {
      if (obj2.hasOwnProperty(key) && obj2[key] !== null) {
        result[key] = typeof obj2[key] === "number" ? obj2[key] : obj2[key];
      }
    }

    return result;
  };

  const jsonToMarkdown = (jsonObject) => {
    let markdown = "";

    function processObject(obj, depth = 1) {
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const value = obj[key];

          if (typeof value === "object" && value !== null) {
            markdown += `${"\t".repeat(depth - 1)}- ${key}:\n`;
            processObject(value, depth + 1);
          } else {
            markdown += `${"\t".repeat(depth - 1)}- ${key}: *${value}*\n`;
          }
        }
      }
    }

    processObject(jsonObject);

    return markdown;
  };

  const handleProperty = (id, message, callback = () => {}) => {
    console.log("üöÄ ~ handleProperty ~ message:", message);
    try {
      // Save data of property
      const jsonData = extractJsonSubstring(message);
      const jsData = JSON.parse(jsonData);
      state[id] = mergeObjects(state[id], jsData);

      if (jsData && Object.keys(jsData).length > 0) {
        handleSendMessage(id, jsonToMarkdown(JSON.stringify(state[id])), {
          parse_mode: "Markdown",
          reply_markup: {
            inline_keyboard: [
              [
                { text: "–ì–æ—Ç–æ–≤–æ", callback_data: "save_property" },
                {
                  text: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
                  callback_data: "edit_in_progress_property",
                },
                { text: "–û—Ç–º–µ–Ω–∏—Ç—å", callback_data: "cancel_property" },
              ],
            ],
          },
        });
        callback();
      } else {
        callback();
      }
    } catch (error) {
      console.log("handleProperty", error);
    }
  };

  const handleOther = (id, message) => {
    try {
      handleSendMessage(id, message, { parse_mode: "Markdown" });
    } catch (error) {
      console.log("handleProperty", error);
    }
  };

  const extractPropertyObject = (inputString) => {
    try {
      // –ò—â–µ–º –Ω–∞—á–∞–ª–æ JSON –æ–±—ä–µ–∫—Ç–∞ —Å —Å–≤–æ–π—Å—Ç–≤–æ–º "property"
      const startIndex = inputString.indexOf('{"property":');
      if (startIndex === -1) {
        throw new Error('–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å–≤–æ–π—Å—Ç–≤–æ "property" –≤ —Å—Ç—Ä–æ–∫–µ');
      }

      // –û–±—Ä–µ–∑–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–æ –Ω–∞—á–∞–ª–∞ JSON –æ–±—ä–µ–∫—Ç–∞
      const jsonString = inputString.substring(startIndex);

      // –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON
      const parsedObject = JSON.parse(jsonString);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—ä–µ–∫—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–≤–æ–π—Å—Ç–≤–æ "property"
      if (!parsedObject.property) {
        throw new Error('–°–≤–æ–π—Å—Ç–≤–æ "property" –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ JSON –æ–±—ä–µ–∫—Ç–µ');
      }

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ JSON –æ–±—ä–µ–∫—Ç–∞
      const textOutsideJson = inputString.substring(0, startIndex);

      return {
        propertyObject: parsedObject.property,
        textOutsideJson: textOutsideJson.trim(), // –û–±—Ä–µ–∑–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
      };
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ JSON –æ–±—ä–µ–∫—Ç–∞:", error.message);
      return null;
    }
  };

  const runChat = await openService.generateChatResponse();

  bot.on("text", async (msg) => {
    const chatId = msg.chat.id;
    const userMessage = msg.text;

    try {
      // history.push(
      //   { role: "user", parts: userMessage },
      //   { role: "model", parts: "" }
      // );

      // dialogs.push(
      //   { role: "user", parts: userMessage },
      //   { role: "model", parts: "" }
      // );

      let label = "";

      const isPropertySubject =
        state[chatId] && Object.keys(state[chatId]).length > 0;

      label = "other";

      console.log("üöÄ ~ bot.on ~ label:", label);

      const labels =
        history[chatId] && history[chatId][label]
          ? history[chatId]
          : (history[chatId] = { ...history[chatId], [label]: [] });

      const messages = labels[label];

      messages.push({ role: "user", content: userMessage });

      // console.log("history", history);

      let stepMessage = null;

      stepMessage = await runChat(userMessage);
      // console.log("üöÄ ~ bot.on ~ stepMessage:", stepMessage);

      const data = JSON.parse(extractJsonSubstring(stepMessage));

      if (Object.keys(data.property).length > 0) {
        handleSendMessage(chatId, jsonToMarkdown(data.property), {
          parse_mode: "Markdown",
          reply_markup: {
            inline_keyboard: [
              [
                { text: "–ì–æ—Ç–æ–≤–æ", callback_data: "save_property" },
                // {
                //   text: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
                //   callback_data: "edit_in_progress_property",
                // },
                // { text: "–û—Ç–º–µ–Ω–∏—Ç—å", callback_data: "cancel_property" },
              ],
            ],
          },
        });
      }

      // messages.push({ role: "assistant", content: data.text });

      handleSendMessage(chatId, data.text);

      // console.log(1111111, JSON.stringify(messages));

      // const data = extractPropertyObject(stepMessage);

      // if (data) {
      //   handleSendMessage(chatId, data.property, {
      //     reply_markup: {
      //       inline_keyboard: [
      //         [
      //           { text: "–ì–æ—Ç–æ–≤–æ", callback_data: "save_property" },
      //           {
      //             text: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
      //             callback_data: "edit_in_progress_property",
      //           },
      //           { text: "–û—Ç–º–µ–Ω–∏—Ç—å", callback_data: "cancel_property" },
      //         ],
      //       ],
      //     },
      //   });
      //   handleSendMessage(chatId, data.text);
      //   messages.push({ role: "assistant", content: property });
      //   messages.push({ role: "assistant", content: text });
      // } else {
      //   try {
      //     const data = JSON.parse(stepMessage);
      //     handleSendMessage(chatId, stepMessage, {
      //       reply_markup: {
      //         inline_keyboard: [
      //           [
      //             { text: "–ì–æ—Ç–æ–≤–æ", callback_data: "save_property" },
      //             {
      //               text: "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
      //               callback_data: "edit_in_progress_property",
      //             },
      //             { text: "–û—Ç–º–µ–Ω–∏—Ç—å", callback_data: "cancel_property" },
      //           ],
      //         ],
      //       },
      //     });
      //     messages.push({ role: "assistant", content: data.property });
      //   } catch (error) {
      //     handleSendMessage(chatId, stepMessage);
      //     messages.push({ role: "assistant", content: stepMessage });
      //   }
      // }

      // const [modelMessage, dialogMessage] = await Promise.all([
      //   geminiService.generateChatText({
      //     prompt: [prompts.property],
      //     history,
      //     temperature: 0,
      //   }),
      //   geminiService.generateChatText({
      //     prompt: prompts.other,
      //     history: dialogs,
      //   }),
      // ]);

      // console.log("üöÄ ~ bot.on ~ modelMessage:", modelMessage);
      // console.log("üöÄ ~ bot.on ~ dialogMessage:", dialogMessage);

      // const jsonData = extractJsonSubstring(modelMessage);

      // let data = null;

      // if (jsonData) {
      //   data = JSON.parse(jsonData);
      //   state[chatId] = mergeObjects(state[chatId], data);

      //   history[history.length - 1] = {
      //     role: "model",
      //     parts: JSON.stringify(state[chatId]),
      //   };
      // }

      // dialogs[dialogs.length - 1] = {
      //   role: "model",
      //   parts: dialogMessage,
      // };

      // if (data && Object.keys(data).length > 0) {
      //   handleSendMessage(
      //     chatId,
      //     jsonToMarkdown(JSON.stringify(state[chatId])),
      //     {
      //       parse_mode: "Markdown",
      //       reply_markup: {
      //         inline_keyboard: [
      //           [{ text: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", callback_data: "button1" }],
      //           [{ text: "–ï—â—ë –¥–∞–Ω–Ω—ã–µ", callback_data: "button2" }],
      //         ],
      //       },
      //     }
      //   );
      // } else {
      //   handleSendMessage(chatId, dialogMessage, { parse_mode: "Markdown" });
      // }
    } catch (err) {
      console.error(err);
      handleSendMessage(chatId, err);
    }
  });

  bot.on("photo", async (msg) => {
    const chatId = msg.chat.id;
    const photo = msg.photo;
    const fileId = msg.photo[0];
    console.log("üöÄ ~ bot.on ~ photo:", fileId);
    const caption = msg.caption;
    // console.log("üöÄ ~ bot.on ~ caption:", caption);

    // try {
    //   const query = await geminiService.generateChatText({
    //     context: dialogContext[chatId].chat,
    //     prompt: userMessage,
    //     history: prompts.photo,
    //     temperature: 0.4,
    //   });
    //   handleSendMessage(query);
    // } catch (err) {
    //   console.error(err);
    //   handleSendMessage(err);
    // }
  });
};
